# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this file,
# You can obtain one at http://mozilla.org/MPL/2.0/.

# This file defines routines that interact with autoconf and configure.

import glob
import logging
import os.path
import sys

from mozbuild.base import Base

class Configure(Base):
    """Provides an interface to configuring a source and object tree.

    Yes, a lot of the code here duplicates functionality in client.mk. This is
    arguably necessary evil. It was originally implemented like this because
    mozbuild was completely outside the build system and making it work with
    client.mk would require hacking client.mk to support some "odd" scenarios.
    This would have made an already difficult to read makefile even more
    complicated.

    If there is a will, the duplication of functionality could be consolidated.
    The static bits could be moved into a JSON file for example and that could
    be converted to a Makefile and included at client.mk run time. Or, the
    static bits could exist in a makefile and mozbuild could use pymake to
    parse them. Even crazier would be to give PyMake an API to build a Makefile
    and we can have code here to build up a dependency graph and then have
    make execute it. Anyway, a unified future is possible if there is desire.
    Until then, less than perfection.
    """
    AUTOCONFS = ['autoconf-2.13', 'autoconf2.13', 'autoconf213']

    def __init__(self, config):
        Base.__init__(self, config)

        self._autoconf = False

    @property
    def configure_scripts(self):
        """The set of configure scripts generated by autoconf."""
        paths = ['configure', 'js/src/configure']

        return [self._get_srcdir_path(p) for p in paths]

    @property
    def autoconf(self):
        """Find the path to autoconf or raise if not found."""
        if self._autoconf is False:
            self._autoconf = self._find_executable_in_path(Configure.AUTOCONFS)

        if not self._autoconf:
            raise Exception('Could not find autoconf 2.13')

        return self._autoconf

    @property
    def configure_mtime(self):
        """Returns the modified time of the generated configure script.

        There are actually multiple configure scripts. We stat them both and
        choose the oldest time.
        """
        oldest = None

        for configure in self.configure_scripts:
            mtime = os.path.getmtime(configure)

            if oldest is None or mtime < oldest:
                oldest = mtime

        return oldest

    def run_configure(self):
        """Runs configure."""

        self._ensure_objdir_exists()

        args = [os.path.join(self.srcdir, 'configure')]
        args.extend(self.config.configure_args)

        env = self.config.get_environment_variables()

        # configure calls out to things that expect MAKE to be defined.
        # We must use the same heuristic as Base._run_make to determine which
        # path to specify.
        if self._is_windows():
            pymake = os.path.join(self.config.source_directory, 'build',
            'pymake', 'make.py')

            env['MAKE'] = ' '.join([sys.executable, pymake]).replace('\\', '/')
        else:
            env['MAKE'] = self._find_executable_in_path(['gmake', 'make'])
            assert env['MAKE'] is not None

        self._run_command_in_objdir(args=args, env=env,
                require_unix_environment=True,
                log_name='configure_output')

        # Not sure why this is here. But, it's in client.mk.
        os.utime(self._get_objdir_path('Makefile'), None)

    def run_autoconfs(self):
        """Runs all necessary autoconf invocations to generate configures."""
        for configure in self.configure_scripts:
            self.run_autoconf(os.path.dirname(configure))

    def run_autoconf(self, directory):
        """Runs autoconf on a file."""

        autoconf = self.autoconf

        self.log(logging.INFO, 'autoconf', {'directory': directory},
                'Running autoconf in {directory} to generate configure')

        self._run_command([autoconf], cwd=directory, log_name='autoconf',
                require_unix_environment=True)

    @property
    def autoconf_dependencies(self):
        """The set of files that trigger a new autoconf run.

        This is equivalent to EXTRA_CONFIG_DEPS in client.mk.
        """
        paths = []

        for configure in self.configure_scripts:
            paths.append(configure + '.in')

        paths.append(self._get_srcdir_path('aclocal.m4'))
        paths.append(self._get_srcdir_path('js/src/aclocal.m4'))

        for path in os.listdir(self._get_srcdir_path('build/autoconf')):
            if not path.endswith('.m4'):
                continue

            paths.append(self._get_srcdir_path('build/autoconf/%s' % path))

        return paths

    @property
    def configure_dependencies(self):
        """The set of files that trigger a new configure run.

        This is equivalent to CONFIG_STATUS_DEPS in client.mk.
        """
        paths = []
        paths.extend(self.configure_scripts)

        simple_paths = [
            'allmakefiles.sh',
            'nsprpub/configure',
            'config/milestone.txt',
            'js/src/config/milestone.txt',
            'browser/config/version.txt',
        ]
        for p in simple_paths:
            paths.append(self._get_srcdir_path(p))

        for p in glob.glob('%s/*/confvars.sh' % self.srcdir):
            paths.append(p)

        # The active config can also influence configure.
        if self.config.loaded_filename:
            paths.append(self.config.loaded_filename)

        return paths

    def ensure_configure(self):
        """Ensures configure is in a good state and run if out of date.

        This emulates logic from client.mk.

        Returns whether configure was actually executed.
        """
        self.ensure_autoconf()

        makefile_path = self._get_objdir_path('Makefile')

        if not os.path.exists(makefile_path):
            self.run_configure()
            return True

        output_mtime = os.path.getmtime(makefile_path)

        configure_mtime = self.configure_mtime
        for dependency in self.configure_dependencies:
            dependency_mtime = os.path.getmtime(dependency)

            if output_mtime < dependency_mtime:
                self.run_configure()
                return True

        return False

    def ensure_autoconf(self):
        did_autoconf = False
        for configure in self.configure_scripts:
            if not os.path.exists(configure):
                self.log(logging.DEBUG, 'trigger_autoconf_no_configure',
                    {'configure_path': configure},
                    'Running autoconf because configure missing: {configure_path}')
                self.run_autoconf(os.path.dirname(configure))
                did_autoconf = True

        if did_autoconf:
            return

        configure_mtime = self.configure_mtime

        for dependency in self.autoconf_dependencies:
            dependency_mtime = os.path.getmtime(dependency)

            if dependency_mtime > configure_mtime:
                self.log(logging.DEBUG, 'trigger_autoconfs_mtime',
                    {'dependency': dependency},
                    'Running autoconf because dependency is newer than configure: {dependency}')
                self.run_autoconfs()
                return

